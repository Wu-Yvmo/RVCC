\documentclass[a4paper, oneside, twocolumn]{ctexbook}
\usepackage[a4paper, left=1cm, right=1cm, top=1cm, bottom=1cm]{geometry}

\usepackage{ctex}

%行间代码
\usepackage{listings}
%指定字体
\usepackage{fontspec}

\lstset{
    basicstyle=\fontspec{JetBrains Mono},
    numbers=left,
    xleftmargin=2cm,
}

\begin{document}

\author{吴雨墨}
\title{徒手写一个C语言编译器：面向RV64GC ISA}
\maketitle

\tableofcontents

\chapter{笔记}
%应该写点什么？
\section{编译出能返回指定数值的程序}
本节的目的是输出下面的汇编程序：

\begin{lstlisting}
.text
.globl main
main:
    li a0, 42
    ret
\end{lstlisting}  
该汇编程序的执行结果将是42。

在该小节中，我们需要了解到，当定义一个外部可见的符号时（不论
它是全局变量/常量还是函数），都需要有.globl name标签。此外，
使用li reg imm向指定寄存器加载值，使用ret指令返回。

\section{支持+ -运算符}
在RV64GC ISA中，双目'+'运算符的执行形式是add dst, src1, src2。
双目'-'运算符的执行形式是sub dst, src1, src2。此外，加减运算
还有立即数版本，存在addi dst, src, imm，但不存在subi指令。

当生成一个形式为l op r的表达式时，逻辑上讲即执行如下伪代码：
\begin{lstlisting}
生成r的代码
将寄存器a0的值压入栈顶
生成l的代码
将栈顶的值弹出到寄存器a1
执行add或sub指令
\end{lstlisting} 

\section{加入一个终结符解析器来解析空格（略）}
\section{改进报错信息（略）}
\section{支持* / ()运算符}
本节引入了* /和()运算符，它们的优先级高于+和-。

\section{支持一元+-运算符}
值的注意的是，一元运算符+不执行运算，而-运算符会将值取反。
这个操作在RV64GC的汇编中，可以通过neg dst, src指令来实现。
neg指令是伪指令，它会被展开为sub rd, x0, rs。

\section{支持== != < <= > >=}
本节主要描述指令选择。我们的约定是，左子表达式的值存储在src1中，右子表达式的值存储在src2中。


==和!=运算符，都先使用xor dst, src1,src2，这一步将把左右子表达式执行结果的不同的比特位置为1，
然后：对于==，使用seqz dst, src；对于!=，使用snez dst, src指令。


对于<运算符，可以使用slt dst, src1, src2指令实现。>=在逻辑上是<运算的反身，
所以可以先执行<运算（即使用指令slt dst, src1, src2），然后再对这个结果进行求反，即使用指令seqz dst, src。

对于>运算符，可以使用slt dst, src2, src1指令实现，因为src1 > src2就是src2 < src1。
<=在逻辑上是>的反身，可以先执行>运算（即使用指令slt dst, src2, src1），然后再对这个结果进行求反，即使用
指令seqz dst, src。

\section{将main.c分割为多个语句（略）}

\section{支持';'分割语句（略）}

\section{支持单字母本地变量（略）}

\section{支持多字母本地变量}
在C语言中，变量可能来自于：1）全局变量2）函数参数3）语句块中的局部变量。但不论变量来自哪里，都首先需要解决同一个问题，
那就是变量寻址，也就是将变量的地址加载到寄存器中。在完成寻址后，就可以通过该寄存器访问内存中的变量。

要使用变量，需要先将它的地址加载到寄存器中，然后再通过寄存器来访问变量。下面我们对3种变量分别进行讨论。

全局变量的寻址。首先是全局变量的定义。在汇编中，要按照这样的方式定义
\begin{lstlisting}
.data
.globl var
var:
    .zero 4
\end{lstlisting}
该代码会创建一个属性为数据的、名为var且大小为4字节的全局变量。
在使用这个变量时，可以方便的借助汇编器提供的伪指令来获取它的地址，即la dst, var。

函数参数的寻址。这里我们只讨论参数个数在[0,6]区间中的情况。函数在传参的时候，会将第0-6个参数分别存储在
寄存器a0-a6中，而在函数调用时，会首先将函数参数移动到自己的栈帧中。在完成了这些工作后，我们还需要解决
如何对这些变量寻址的问题。这就要求我们在处理函数的解析时，也把函数参数考虑进来。

在一个函数栈帧中，变量的布局是：（高地址）栈帧=>栈（低地址）。而栈帧的结构是：（高地址）函数参数0-6=>先定义的变量=>后定义的变量（低地址）。

此外，变量还分为基本类型和聚合类型，而聚合类型又进一步分为结构体和数组。这里只讨论一维数组和全部元素均为基本元素的结构体。
当访问某数组中的某个元素时，第一步先对该数组寻址，第二部根据下标计算偏移量。第三部将数组的寻址结果和偏移量相加
得到元素的地址，此后就可以根据这个地址对数组元素进行访问。当访问某结构体中的某元素时，可将结构体视为元素类型不相同的
数组，第一个成员类似于数组的0号数据，第二个成员类似于数组的1号数据，以此类推。访问结构体成员时，需要先计算出该成员
在结构体中的偏移量，然后将结构体的地址和偏移量相加，得到该成员的地址，最后根据这个地址访问该成员。

在常规的Block语句解析中，专门设置有一个Vec<VarInfo>字段保存本地变量的信息。该字段的存在意义是提供类型索引
和偏移量索引。

是不是VarDescribe的FunctionDescribe中，应该添加一个Vec<VarInfo>字段？
我认为这是应该的。这能有效的解决变量寻址的问题，需要讨论的是它带来的问题。
首先，有些函数声明中，可能并不给形式参数提供名称。到这里我们应该怎么办？
我的想法是，在即将解析结构体的时候对VarInfo进行设置。

\end{document}